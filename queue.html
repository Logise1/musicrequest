<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Queue Player</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
</head>

<body>
    <div id="startOverlay"
        style="position:fixed; inset:0; background:#000; z-index:9999; display:flex; justify-content:center; align-items:center; flex-direction:column; cursor:pointer;"
        onclick="startDJ()">
        <h1>CLICK TO START PLAYER</h1>
        <p style="color:#666">REQUIRED FOR AUDIO</p>
    </div>

    <div class="player-wrapper" style="border:none; margin-bottom: 1rem;">
        <div class="video-container" style="border: 2px solid #333; position: relative;">
            <div id="player"></div>
            <div id="playerOverlay"
                style="position: absolute; inset: 0; z-index: 10; pointer-events: auto; background: transparent;"></div>
        </div>

        <div class="now-playing-info">
            <div>
                <p style="font-size:0.8rem; color:#666; margin-bottom:5px;">NOW PLAYING</p>
                <div id="currentTitle">WAITING FOR REQUESTS...</div>
            </div>
            <div id="countdown">00:00</div>
        </div>
    </div>

    <div class="container">
        <div style="border: 1px solid #444; padding: 15px; margin-bottom: 25px; background: #111; border-radius: 8px;">
            <h3 style="margin-top:0; color: #fff; border-bottom: 1px solid #333; padding-bottom: 10px;">ADMIN CONTROLS
            </h3>

            <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-bottom:15px;">
                <label style="color:#aaa;">Max Time (sec):</label>
                <input type="number" id="maxDurInput" value="120"
                    style="padding:5px; width:60px; background:#222; border:1px solid #444; color:white;">
                <button onclick="updateSettings()"
                    style="padding:5px 15px; cursor:pointer; background:#333; border:none; color:white;">APPLY</button>
            </div>

            <div style="display:flex; gap:10px; flex-wrap:wrap;">
                <button onclick="playNext()"
                    style="padding:8px 15px; cursor:pointer; background:#d4b106; border:none; color:black; font-weight:bold; border-radius:4px;">SKIP
                    SONG</button>
                <button onclick="clearQueue()"
                    style="padding:8px 15px; cursor:pointer; background:#aa0000; border:none; color:white; font-weight:bold; border-radius:4px;">CLEAR
                    QUEUE</button>
                <button onclick="toggleProjection()"
                    style="padding:8px 15px; cursor:pointer; background:#00ffcc; border:none; color:black; font-weight:bold; border-radius:4px;">PROJECTION
                    MODE</button>
            </div>
        </div>

        <div style="border-bottom: 1px solid #333; padding-bottom:10px; margin-bottom:20px; text-align:left;">
            <span style="font-weight:bold; font-size:1.2rem;">UP NEXT</span>
        </div>
        <div id="queueList" class="queue-list">
            <!-- Items -->
        </div>
    </div>

    <!-- Projection Mode UI -->
    <div class="projection-ui">
        <div class="projection-header">
            <div class="now-playing-small">NOW PLAYING: <span id="projCurrentTitle">WAITING...</span></div>
            <div class="next-up-small">NEXT UP: <span id="projNextTitle">-</span></div>
        </div>

        <div id="projectionAnnouncement" class="projection-announcement">
            <div class="announcement-label">NEXT UP</div>
            <div id="projAnnounceTitle" class="announcement-title">SONG TITLE</div>
        </div>

        <div class="projection-progress-container">
            <div id="projProgressBar" class="projection-progress-bar"></div>
        </div>
    </div>

    <button class="exit-projection-btn" onclick="toggleProjection()">EXIT PROJECTION</button>

    <script>
        const firebaseConfig = {
            databaseURL: "https://toon-acb19-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "toon-acb19"
        };

        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        let MAX_DURATION = 120;

        // State
        let player;
        let isChanging = false;
        let countdownInterval = null;
        let localQueue = []; // Local mirror of DB Queue

        // New State for Queue Management
        let currentSong = null;
        let isSessionActive = false;
        let loadingTimeout = null;
        let isWaitingForNext = false;
        let isProjectionMode = false;

        function toggleProjection() {
            isProjectionMode = !isProjectionMode;
            document.body.classList.toggle('projection-active', isProjectionMode);

            // Try to go fullscreen
            if (isProjectionMode) {
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen().catch(e => console.log("Fullscreen failed", e));
                }
            } else {
                if (document.exitFullscreen && document.fullscreenElement) {
                    document.exitFullscreen().catch(e => console.log("Exit fullscreen failed", e));
                }
            }
        }

        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement && isProjectionMode) {
                isProjectionMode = false;
                document.body.classList.remove('projection-active');
            }
        });

        function initListeners() {
            // Queue Listener
            db.ref('requests').on('value', (snapshot) => {
                const data = snapshot.val();
                if (!data) localQueue = [];
                else localQueue = Object.entries(data).map(([key, val]) => ({ key, ...val }));

                renderQueue(localQueue);

                // Update Projection Next Up
                if (localQueue.length > 0) {
                    document.getElementById('projNextTitle').innerText = localQueue[0].title.toUpperCase();
                } else {
                    document.getElementById('projNextTitle').innerText = "-";
                }

                // Auto Trigger if idle and safe
                if (!isSessionActive && !isChanging && localQueue.length > 0) {
                    if (player && typeof player.loadVideoById === 'function') playNext();
                } else if (isWaitingForNext && !isChanging && localQueue.length > 0) {
                    isWaitingForNext = false;
                    if (player && typeof player.loadVideoById === 'function') playNext();
                }
            });
        }

        // --- Admin Functions ---
        function updateSettings() {
            const val = parseInt(document.getElementById('maxDurInput').value);
            if (val > 0) {
                MAX_DURATION = val;
                alert('MAX DURATION UPDATED TO: ' + MAX_DURATION + 's');
            }
        }

        function removeRequest(key) {
            if (!confirm('Delete this request?')) return;
            db.ref('requests/' + key).remove();
        }

        function clearQueue() {
            if (!confirm('DELETE ALL SONGS IN QUEUE?')) return;
            db.ref('requests').remove();
        }

        // --- YouTube API ---
        function onYouTubeIframeAPIReady() {
            player = new YT.Player('player', {
                height: '100%',
                width: '100%',
                playerVars: {
                    'autoplay': 1,
                    'controls': 0,
                    'disablekb': 1,
                    'iv_load_policy': 3,
                    'playsinline': 1,
                    'modestbranding': 1,
                    'rel': 0,
                    'showinfo': 0,
                    'fs': 0,
                    'autohide': 1
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange,
                    'onError': onPlayerError
                }
            });
        }

        function onPlayerReady(event) {
            console.log("Player Ready");
        }

        function onPlayerStateChange(event) {
            // 1. PLAYING (Start Session if new, or Handle Ads)
            if (event.data === YT.PlayerState.PLAYING) {
                const data = player.getVideoData();
                const playingId = data ? data.video_id : null;

                // Check if it's the requested song
                if (currentSong && playingId === currentSong.id) {
                    // Real Content
                    if (player.isMuted()) player.unMute();
                    player.setVolume(100);

                    if (!isSessionActive) {
                        console.log("DEBUG: Real content started. Starting Session...");
                        startSession();
                    }
                } else {
                    // Ad or Mismatch
                    console.log("DEBUG: ID Mismatch or Ad detected. Muting...");
                    if (!player.isMuted()) player.mute();
                }
            }

            // 2. ENDED (Next)
            if (event.data === YT.PlayerState.ENDED) {
                if (isSessionActive) {
                    console.log("Video ended natural, playing next...");
                    playNext();
                }
            }

            // 3. PAUSED (Force Play)
            if (event.data === YT.PlayerState.PAUSED) {
                if (isSessionActive && !isChanging) {
                    console.log("DEBUG: Pause detected, forcing play...");
                    player.playVideo();
                }
            }
        }

        function onPlayerError(event) {
            console.error("Player Error:", event.data);
            // Force skip even if "changing" (lock stuck check)
            setTimeout(playNext, 2000);
        }

        function startDJ() {
            document.getElementById('startOverlay').style.display = 'none';

            // 1. Lock system
            isChanging = true;

            // 2. Start Listeners (Data Sync)
            initListeners();

            // 3. Check for Resume Session
            db.ref('now_playing').once('value').then(snap => {
                const playing = snap.val();
                let resumed = false;

                if (playing) {
                    const elapsed = (Date.now() - playing.startTime) / 1000;
                    const LIMIT = MAX_DURATION;
                    const realDuration = playing.durationSeconds || LIMIT;

                    if (elapsed < realDuration) {
                        console.log("Resuming session:", playing.title);
                        resumePlaying(playing, elapsed);
                        resumed = true;
                    }
                }

                if (!resumed) {
                    // Release lock, Listener will pick up queue if exists
                    isChanging = false;
                    // Force check just in case listener already fired while locked
                    if (localQueue.length > 0) playNext();
                }
            });
        }

        function resumePlaying(item, elapsedSeconds) {
            // isChanging is ALREADY TRUE from startDJ
            currentSong = item;
            isSessionActive = true; // Already active

            document.getElementById('currentTitle').innerText = item.title.toUpperCase();

            if (player && typeof player.loadVideoById === 'function') {
                player.loadVideoById(item.id, parseInt(elapsedSeconds));
                player.playVideo();
            }

            // Restore Timer
            const LIMIT = MAX_DURATION;
            let realDuration = item.durationSeconds || LIMIT;
            let strictLimit = realDuration >= LIMIT;
            // Recalculate remaining
            let timerDuration = (strictLimit ? LIMIT : (realDuration + 10)) - elapsedSeconds;
            let timeLeft = (strictLimit ? LIMIT : realDuration) - elapsedSeconds;

            updateTimer(timeLeft);

            // Release lock safely
            setTimeout(() => { isChanging = false; }, 1000);

            if (countdownInterval) clearInterval(countdownInterval);
            countdownInterval = setInterval(() => {
                timeLeft--;
                if (timeLeft >= 0) updateTimer(timeLeft);

                timerDuration--;
                if (timerDuration <= 0) {
                    clearInterval(countdownInterval);
                    if (localQueue.length > 0) {
                        playNext();
                    } else {
                        isWaitingForNext = true;
                        document.getElementById('countdown').innerText = "00:00";
                    }
                }
            }, 1000);
        }

        // --- Audio & TTS ---
        const announcementSFX = new Audio('nextsong.ogg');

        function playAnnouncement(title, user) {
            console.log("DEBUG: Starting Announcement for:", title);
            return new Promise((resolve) => {
                const safety = setTimeout(() => {
                    console.log("DEBUG: Announcement Timed Out (Safety)");
                    resolve();
                }, 6000);

                announcementSFX.volume = 0.5;
                announcementSFX.currentTime = 0;
                announcementSFX.play().catch(e => console.log("DEBUG: SFX Failed", e));

                if ('speechSynthesis' in window) {
                    window.speechSynthesis.cancel();

                    const safeTitle = title.substring(0, 50);
                    const userText = user ? ` pedido por ${user}` : '';
                    const text = `Ahora suena: ${safeTitle}${userText}`;
                    console.log("DEBUG: Speaking TTS:", text);

                    // Show Projection Announcement
                    const announceEl = document.getElementById('projectionAnnouncement');
                    const announceTitleEl = document.getElementById('projAnnounceTitle');
                    if (announceEl && announceTitleEl) {
                        announceTitleEl.innerText = title.toUpperCase();
                        announceEl.classList.add('active');
                    }

                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.lang = 'es-ES';
                    utterance.rate = 1.1;
                    utterance.volume = 1.0;

                    utterance.onend = () => {
                        console.log("DEBUG: TTS Ended");
                        if (announceEl) announceEl.classList.remove('active');
                        clearTimeout(safety);
                        resolve();
                    };

                    utterance.onerror = (e) => {
                        console.log("DEBUG: TTS Error", e);
                        if (announceEl) announceEl.classList.remove('active');
                        clearTimeout(safety);
                        resolve();
                    };

                    window.speechSynthesis.speak(utterance);
                } else {
                    console.log("DEBUG: No TTS support");
                    clearTimeout(safety);
                    resolve();
                }
            });
        }

        // --- Logic ---
        async function playNext() {
            if (isChanging) return;

            if (localQueue.length === 0) {
                goIdle();
                return;
            }

            isChanging = true;
            isSessionActive = false; // Reset session
            if (countdownInterval) clearInterval(countdownInterval);
            if (loadingTimeout) clearTimeout(loadingTimeout);

            // 1. Clear "Now Playing" immediately so clients know song ended
            db.ref('now_playing').remove();

            // 2. Play Silence Video (Stop previous music instantly)
            if (player && typeof player.loadVideoById === 'function') {
                player.loadVideoById("1JPwiLeo4WY");
            }

            const next = localQueue[0];
            currentSong = next; // Store pending

            console.log("DEBUG: playNext PREPARE. Next song:", next.title);

            // Optimistic UI
            renderQueue(localQueue.slice(1));
            document.getElementById('currentTitle').innerText = "ANNOUNCING...";
            document.getElementById('projCurrentTitle').innerText = "ANNOUNCING...";

            // 3. Wait for TTS (Music is now silent)
            await playAnnouncement(next.title, next.userName);

            document.getElementById('currentTitle').innerText = "LOADING VIDEO...";
            document.getElementById('projCurrentTitle').innerText = "LOADING VIDEO...";

            // Remove from Queue (It's now 'pending' in player)
            db.ref('requests/' + next.key).remove().catch(e => console.error(e));

            // Load Real Video
            let attempts = 0;
            while ((!player || typeof player.loadVideoById !== 'function') && attempts < 20) {
                await new Promise(r => setTimeout(r, 250));
                attempts++;
            }

            if (player && typeof player.loadVideoById === 'function') {
                player.loadVideoById(next.id);
                player.setVolume(100);
                if (player.isMuted()) player.unMute();

                // Safety Timeout: If video doesn't start in 15s, skip
                loadingTimeout = setTimeout(() => {
                    if (!isSessionActive) {
                        console.error("DEBUG: Loading Timeout. Skipping...");
                        playNext();
                    }
                }, 15000);

            } else {
                console.error("Player invalid");
                isChanging = false;
            }
        }

        function startSession() {
            if (loadingTimeout) clearTimeout(loadingTimeout);
            isSessionActive = true;

            // Register in DB
            const nowPlayingData = { ...currentSong, startTime: Date.now() };
            if (nowPlayingData.key) delete nowPlayingData.key;

            db.ref('now_playing').set(nowPlayingData);

            // UI
            const titleUpper = currentSong.title.toUpperCase();
            document.getElementById('currentTitle').innerText = titleUpper;
            document.getElementById('projCurrentTitle').innerText = titleUpper;

            // Timer Logic
            const LIMIT = MAX_DURATION;
            let realDuration = currentSong.durationSeconds || LIMIT;
            let strictLimit = realDuration >= LIMIT;
            let timerDuration = strictLimit ? LIMIT : (realDuration + 10);
            let timeLeft = strictLimit ? LIMIT : realDuration;

            // Release Lock
            isChanging = false;

            updateTimer(timeLeft);

            if (countdownInterval) clearInterval(countdownInterval);
            countdownInterval = setInterval(() => {
                // Only tick if playing? For now simple absolute timer
                timeLeft--;
                if (timeLeft >= 0) updateTimer(timeLeft);

                timerDuration--;
                if (timerDuration <= 0) {
                    clearInterval(countdownInterval);
                    if (localQueue.length > 0) {
                        playNext();
                    } else {
                        isWaitingForNext = true;
                        document.getElementById('countdown').innerText = "00:00";
                    }
                }
            }, 1000);
        }

        function goIdle() {
            isSessionActive = false;
            currentSong = null;
            document.getElementById('currentTitle').innerText = "WAITING FOR REQUESTS...";
            document.getElementById('projCurrentTitle').innerText = "WAITING...";
            document.getElementById('countdown').innerText = "00:00";
            document.getElementById('projProgressBar').style.width = "0%";
            db.ref('now_playing').remove();
            if (player && player.stopVideo) player.stopVideo();
            isChanging = false;
        }

        function updateTimer(s) {
            const min = Math.floor(s / 60).toString().padStart(2, '0');
            const sec = (Math.floor(s) % 60).toString().padStart(2, '0'); // floor s just in case
            document.getElementById('countdown').innerText = `${min}:${sec}`;

            // Update Projection Progress Bar
            const LIMIT = MAX_DURATION;
            let realDuration = (currentSong && currentSong.durationSeconds) || LIMIT;
            let total = realDuration > LIMIT ? LIMIT : realDuration;
            let elapsed = total - s;
            let percent = (elapsed / total) * 100;
            if (percent < 0) percent = 0;
            if (percent > 100) percent = 100;
            document.getElementById('projProgressBar').style.width = percent + "%";
        }

        function renderQueue(queue) {
            const list = document.getElementById('queueList');
            if (queue.length === 0) {
                list.innerHTML = '<div style="opacity:0.5; padding:20px;">QUEUE EMPTY</div>';
                return;
            }

            const html = queue.map(item => `
                <div class="queue-item">
                    <img src="${item.thumb}" alt="cover">
                    <div class="info">
                        <span class="title">${item.title}</span>
                        <div style="display:flex; justify-content:space-between; width:100%; margin-top:5px;">
                            <span class="status">${item.userName ? item.userName.toUpperCase() : (item.channel ? item.channel.toUpperCase() : 'UNKNOWN')}</span>
                            <div style="display:flex; align-items:center; gap:10px;">
                                <span class="status" style="border:1px solid #333; padding:2px 6px;">${item.duration || '2:00'}</span>
                                <button onclick="removeRequest('${item.key}')" style="background:#cc0000; color:white; border:none; cursor:pointer; padding:2px 8px; font-size:0.7rem; border-radius:3px;">X</button>
                            </div>
                        </div>
                    </div>
                </div>
            `).join('');
            list.innerHTML = html;
        }

        // Load YouTube API Dynamically to prevent race conditions
        var tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        var firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

    </script>
</body>

</html>